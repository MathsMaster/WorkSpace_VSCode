/**
 * @file Process.c
 * @author your name (you@domain.com)
 * @brief 编写一个C程序,并使用系统调用fork()创建一个子进程. 1,在子进程中分别输出当前进程为子进程的提示，当前进程的PID,和父进程的PID
 * @version 0.1
 * @date 2022-04-26
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/wait.h>
#include <stdlib.h>
#include "Utils.h"

int main()
{
    printf(
            "首先,民主自由确实是个好东西.\n"
            "但是中国大陆现在最需要做的就是进行产业升级，进军世界产业链上游,而这正是一党专政的优势所在。\n"
            "务必看完再回\n"
            "至少,在未来中国完成产业升级，进军世界产业链上游之前，我依然选择支持中国共产党的一党专政.\n"
            "理由4点如下:\n"
                "1,此时的中国大陆需要共产党,虽然中国工产党有着腐败和集权的问题，但是中国大陆现在是什么情况？ 中国大陆到现在依然有近6亿人口月收入不足200美元,即便是其他8亿人，大多数每天都是要工作12个小时，为什么会这样。 不就是因为我们处在世界产业链的下游，只能给国际市场提供低廉的产品，来换取微薄的收入吗？\n" 
                "美国和西方他们的祖先可以通过屠杀美洲原住民来实现财富积累，进而完成产业升级，最终始终占据这世界产业链的最上游， 他们的人民可以每天只工作8个小时，就能获取到世界市场上的各种优渥产品。 中国的那6亿月收入只有不足200美元的人民，他们就不配每天只工作8小时吗，他们就不配去享有优渥的物质待遇吗？"
                 "所以，现在我们中国大陆最最重要的任务是，进行产业升级，往高端制造业进军。 尤其是现在，美国不仅对中国进行各种经济制裁和技术封锁，最终目的不就是想把中国大陆阻挡在世界产业链的上游之外，防止有人去抢他们的蛋糕吗。 凭什么西方能占据高端市场，中国人就不配，中国的那6亿人口活该只有不足200美元的月收入，其他大多数人活该每天要加班工作12个小时？\n "
                 "你觉得以中国现在的情况，有资格去谈什么民主和自由吗。虽然我不支持中共的政策， 但是在进行产业升级，往世界产业链上游进军的目标上，我依然选择支持一党专政。至少在集中力量办大事方面，一党专政对此时的中国大陆更重要。 倘若现在中国大陆进行民主化改革，后果很大可能就是像美国的基础设施建设一样，谈了快20年了，还没落地执行。\n\n"
                "2,西方民主导致的结果就是政府行政效率的低下,或者民粹主义的盛行,丧失了高效和理智。\n"
                "比如美国的两党政治,政党轮替导致的特朗普上台后，就直接废了奥巴马的医保法案。而且，美国从小布什时代就开始谈基础设施建设更新,结果现在都快过了20年了，还没真正落地执行。\n"
                "比如澳大利亚的民粹主义带来的各种问题，本来澳大利亚有1/3的出口是到中国的，结果就是因为被民粹主义绑架,结果硬着头皮也要取消对中国的出口\n\n"
                "3,世上有哪个国家政党能同时做到，高效，理智，民主，自由。要么就像中国大陆选择高效,理智,放弃民主,自由;要么就像美国和欧洲，选择民主自由，放弃高效和理智。\n"
                "或者就是像新加坡，日本，台湾一样，打着民主的旗号，行一党专政之实。\n "
                "新加坡日本台湾这三地，他们的执政党因为长期执政，尚且还能保持政策的延续性。执政党可以把自己党派的人推到政府各个重要岗位，进行锻炼历练，也就意味着，执政党的执政能力越来越强，而相对的在野党的执政经验越来越差。让民众去选举，一边是有经验的执政党，一边是没经验的在野党，这还用得着选吗？ 最终，执政党做到了长期执政，保持政策的延续性，这不就是相当于一党专政了吗。\n "
                "新加坡日本台湾这三地在野党存在的唯二作用：1，警醒执政党，别贪腐腐败，否则在野党还是有可能上台的。2，让民众以为自己有民主自由，可以进行选举。可一边是有经验的执政党，一边是没经验的在野党，选哪个不是妥妥的吗？ 所以说，像新加坡，日本，台湾一样，实际上就是打着民主的旗号，行一党专政之实。 和大陆共产党相比，他们唯一的优势就是廉洁方面做的好些。\n\n"
                "4,只要控制了台湾的大多数媒体，天天给民众灌输对自己党派有利的消息，最后选哪个党，这不是确定了的吗？ 这叫民主吗？ 可叹的是，在大陆这边，虽然共产党也是天天灌输对自己党有利的消息，但大多数人早已知晓真实情况了。\n"
                "好在的是，台湾的地方领导人柯文哲不仅看到了这一点，也敢于指出: 台湾就是民进党一党专政。\n"
                "至于台湾其他人，却自以为自己还在民主的梦幻泡影之中，既不敢认清，也不想认清现实。\n\n"
            "总结:\n"
            "1,共产党虽然在民主方面不靠谱，但至少搞经济是把好手,哪有你们的媒体那样说的一无是处啊。\n"
            "2,既然你们身在台湾，新加坡，日本就不要谈什么民主自由了，真以为自己的政府不是一党专政了吗？\n"
            "3,人家中国大陆都已经大大方方地承认了自己，就是一党专政,目前只关心集中力量办大事,发展经济，进行产业升级.\n "
            "而你们是,既想要一党专政的优势，又想要给自己披上民主自由的外衣,这不就是那既想当啥,又想立啥了吗。\n");

    pid_t childpid = 0;//进程id
    int retval;//由用户提供的子进程的返回号??? 这玩意有什么用
    int status;//进程状态
    printf("初始时 childpid : %d \n",childpid);
    //创建个子进程;如果==0,表示当前在子进程中运行;如果 >0,表示当前是在父进程中，返回的是其子进程的pid;
    childpid = fork();//C语言里面的进程竟然与Java差异这么大,执行完这行代码后,竟然有两个进程同时往下执行了
    printf("当前获取的childpid : %d \n",childpid);
    printTime();
    if(childpid >= 0)//进程创建成功
    {
        if(childpid == 0)//表示当前处在子进程中
        {
            printf("Child : 我是子进程 \n");
            printTime();
            printf("Child : 这是我的PID %d \n",getpid());
            printf("Child : 这是我的父进程的PID %d \n",getppid());
            printf("Child : 这是fork()的返回值 %d \n",childpid);
            //execl("/bin/ls","ls",NULL,NULL);
            printf("Child : 让我睡眠1秒....\n");
            sleep(1);
            printf("Child : 输入子进程执行完毕后的返回值，用于传给父进程\n");
            scanf(" %d",&retval);//传进去的值竟然不能超过256，否则将会溢出
            printf("Child : 退出子进程\n");
            exit(retval);//子进程退出时的值retval,父进程可以用wait()得到
        }else{//返回一个新的PID,这表示当前处在父进程中
            printf("Parent : 我是父进程\n");
            printTime();
            printf("Parent : 这是我的PID: %d \n",getpid());//输出的实际上是当前进程,也就是父进程的pid
            printf("Parent : 这是我的子进程的pid %d \n",childpid);//输出当前进程的子进程的pid
            printf("Parent : 等待我的子进程结束,并保存他的状态\n");
            wait(&status);//该函数会使父进程暂停执行,直到他的一个子进程结束为止;并且该函数会使当前进程阻塞
            printf("Parent : 我的子进程退出时的返回值: %d \n",WEXITSTATUS(status));
            printf("Parent : 父进程退出\n");
            exit(0);//父进程退出
            //不再继续往下执行
        }
    }else {//进程创建失败
        printf("创建进程失败 \n");
        perror("创建进程失败 ");
        exit(0);
    }

}